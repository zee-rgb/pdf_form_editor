<%# PDF Editor - Simple Vanilla JS Implementation %>
<% content_for :full_width, true %>

<style>
  .pdf-container {
    position: relative;
    width: 100%;
    height: 100%;
  }
  
  .pdf-element {
    position: absolute;
    background-color: transparent;
    border: none;
    padding: 3px 8px;
    z-index: 100;
    /* Fixed positioning ensures elements stay in place */
    transform: translate(-50%, -50%);
  }
  
  .pdf-element.signature {
    padding: 2px 6px;
  }
  
  .pdf-element .remove-btn {
    position: absolute;
    top: -6px;
    right: -6px;
    width: 14px;
    height: 14px;
    background-color: #e53e3e;
    border-radius: 50%;
    color: white;
    font-size: 10px;
    text-align: center;
    line-height: 14px;
    cursor: pointer;
    display: none;
  }
  
  .pdf-element:hover .remove-btn {
    display: block;
  }
  
  .pdf-element.dragging {
    opacity: 0.8;
    z-index: 200;
  }
  
  .position-indicator {
    color: #16a34a;
    font-weight: bold;
  }
</style>

<div class="min-h-screen bg-gray-100">
  <!-- Top toolbar -->
  <div class="bg-white border-b p-4 flex items-center gap-3 sticky top-0 z-50">
    <div class="flex items-center gap-3 flex-1 min-w-0 overflow-hidden">
      <h1 class="text-xl font-bold truncate"><%= @pdf_document.title %></h1>
    </div>
    <div class="flex gap-3 shrink-0 ml-auto whitespace-nowrap">
      <button id="save-changes-btn" class="btn bg-green-600 hover:bg-green-700 text-white">Save Changes</button>
      <button id="download-pdf-btn" class="btn btn-primary text-white">Download PDF</button>
      <%= link_to "â† Back to PDFs", pdf_documents_path, class: "btn" %>
    </div>
  </div>

  <!-- Notification area -->
  <div id="notification-container" class="max-w-lg mx-auto mt-4" aria-live="polite"></div>

  <!-- Two-column layout -->
  <div class="flex w-full">
    <!-- Left sidebar - Tools -->
    <aside class="w-80 shrink-0 bg-white border-r p-4 space-y-6" aria-label="PDF editing tools">
      <!-- Add Text Form -->
      <div>
        <h3 class="text-lg font-medium text-gray-900 mb-3">Add Text</h3>
        <div class="space-y-3">
          <label for="text-input" class="block text-sm font-medium text-gray-700">Text to add</label>
          <input type="text" id="text-input" placeholder="Enter text..." class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
          
          <!-- Position is tracked internally, no need to show user -->
          
          <button type="button" id="add-text-btn" class="w-full bg-purple-600 text-white py-2 px-4 rounded-md hover:bg-purple-700" aria-label="Add text to PDF">Add Text</button>
        </div>
      </div>

      <!-- Add Signature -->
      <div>
        <h3 class="text-lg font-medium text-gray-900 mb-3">Add Signature</h3>
        <div class="space-y-3">
          <label for="signature-input" class="block text-sm font-medium text-gray-700">Signature</label>
          <input type="text" id="signature-input" placeholder="Type your name..." class="w-full px-3 py-2 border rounded-md">
          
          <label for="signature-font" class="block text-sm font-medium text-gray-700 mt-3">Font style</label>
          <select id="signature-font" class="w-full px-3 py-2 border rounded-md">
            <option value="Dancing Script">Dancing Script</option>
            <option value="Great Vibes">Great Vibes</option>
            <option value="Allura">Allura</option>
          </select>
          
          <!-- Signature Preview -->
          <div class="border rounded-md p-3 bg-gray-50 mt-3 text-center">
            <p class="text-sm text-gray-600 mb-2">Preview:</p>
            <div id="signature-preview" class="h-20 flex items-center justify-center bg-white" aria-label="Signature preview">
              <div class="text-gray-400 italic text-sm">Type your name above to see preview</div>
            </div>
          </div>
          
          <!-- Position is tracked internally, no need to show user -->
          
          <button type="button" id="add-signature-btn" class="w-full bg-gray-600 text-white py-2 px-4 rounded-md hover:bg-gray-700" aria-label="Add signature to PDF">Add Signature</button>
        </div>
      </div>
    </aside>

    <!-- Right main area - PDF Display -->
    <div class="flex-1 bg-gray-800 flex flex-col overflow-auto">
      <!-- PDF Viewer -->
      <div class="flex-1 relative">
        <% if @pdf_document.pdf_file.attached? %>
          <div id="pdf-container" class="h-full relative">
            <% if @pdf_document.processed_pdf.attached? %>
              <embed 
                src="<%= stream_pdf_document_path(@pdf_document) %>" 
                type="application/pdf" 
                width="100%" 
                height="100%"
                class="pdf-embed"
                id="pdf-viewer"
              />
            <% else %>
              <embed 
                src="<%= stream_pdf_document_path(@pdf_document) %>" 
                type="application/pdf" 
                width="100%" 
                height="100%"
                class="pdf-embed"
                id="pdf-viewer"
              />
            <% end %>
            
            <!-- Clickable overlay for position selection -->
            <div 
              id="pdf-overlay"
              class="absolute inset-0 cursor-crosshair" 
              aria-label="Click to select position on PDF"
              style="z-index: 50; background: transparent; border: none;"
            ></div>
          </div>
        <% else %>
          <div class="h-full w-full flex items-center justify-center bg-gray-200 text-gray-500 text-lg font-medium">
            No PDF attached
          </div>
        <% end %>
      </div>
    </div>
  </div>
</div>

<script>
  // Global variables that must be initialized with each PDF's specific data
  // Store the current PDF ID to prevent cross-contamination
  var pdfDocumentId = <%= @pdf_document.id %>;
  // Initialize with this PDF's specific overlay elements
  var overlayElements = <%= raw (@pdf_document.overlay_elements || []).to_json %>;
  var selectedPosition = { x: 50, y: 50 };
  var nextElementId = <%= @pdf_document.overlay_elements ? @pdf_document.overlay_elements.length : 0 %>;
  
  // Check URL to ensure we're working with the correct PDF
  function validateCurrentPdf() {
    const urlPdfId = parseInt(window.location.pathname.split('/')[2]);
    return urlPdfId === pdfDocumentId;
  }
  
  // Ensure we can access the global showNotification function
  function checkNotificationFunction() {
    if (!window.showNotification) {
      console.log('Created fallback notification function');
      // Create a fallback notification function
      window.showNotification = function(message, type = 'info') {
        // Basic implementation for when the notification component isn't loaded
        console.log(`Notification (${type}):`, message);
        
        // Optionally try to show in UI if we can find a container
        const notificationArea = document.getElementById('notification-area');
        if (notificationArea) {
          const alertDiv = document.createElement('div');
          alertDiv.className = `alert alert-${type} my-2 p-2 rounded shadow-sm`;
          alertDiv.innerHTML = message;
          notificationArea.appendChild(alertDiv);
          
          // Auto-dismiss after 5 seconds unless it's an error
          if (type !== 'error') {
            setTimeout(() => {
              if (alertDiv && alertDiv.parentNode) {
                alertDiv.parentNode.removeChild(alertDiv);
              }
            }, 5000);
          }
        }
      };
    } else {
      console.log('Global showNotification function found');
    }
    
    // Add error prevention for runtime.lastError messages
    preventRuntimeErrors();
  }
  
  // Prevent runtime.lastError messages in console
  function preventRuntimeErrors() {
    // Override console.error for runtime.lastError messages
    const originalConsoleError = console.error;
    console.error = function() {
      // Skip logging runtime.lastError about message port closed
      if (arguments[0] && 
          typeof arguments[0] === 'string' && 
          (arguments[0].includes('message port closed') || 
           arguments[0].includes('runtime.lastError'))) {
        return;
      }
      return originalConsoleError.apply(this, arguments);
    };
  }
  
  // Initialize immediately and also when the DOM is fully loaded and when Turbo navigates
  (function init() {
    if (document.readyState === "loading") {
      document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
      // DOM already loaded, initialize directly
      initializeApp();
    }
    
    // Also initialize when navigating between pages with Turbo
    document.addEventListener('turbo:load', initializeApp);
    document.addEventListener('turbo:render', initializeApp);
  })();
  
  function initializeApp() {
    console.log('Initializing PDF editor app...');
    
    // Make sure we have access to showNotification function
    checkNotificationFunction();
    
    // Cleanup any existing event listeners to prevent duplicates
    cleanupEventListeners();
    // Load the fonts
    loadFonts();

    // Setup PDF click handler
    setupEventHandlers();
    
    // Load only the server-saved elements
    // By getting the elements directly from the server-rendered variable
    // This ensures we don't get duplicates when navigating back to the page
    overlayElements = <%= raw (@pdf_document.overlay_elements || []).to_json %>;
    
    // Render existing elements
    renderElements();
    
    // Initial signature preview
    updateSignaturePreview();
  }
  
  function loadFonts() {
    if (!document.getElementById('signature-fonts')) {
      const link = document.createElement('link');
      link.id = 'signature-fonts';
      link.rel = 'stylesheet';
      link.href = 'https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&family=Great+Vibes&family=Allura&display=swap';
      document.head.appendChild(link);
    }
  }
  
  function setupEventHandlers() {
    // PDF overlay click handler
    const pdfOverlay = document.getElementById('pdf-overlay');
    if (pdfOverlay) {
      pdfOverlay.addEventListener('click', handlePdfClick);
    }
    
    // Add text button
    const addTextBtn = document.getElementById('add-text-btn');
    if (addTextBtn) {
      addTextBtn.addEventListener('click', function(e) {
        e.preventDefault();
        addTextElement();
      });
    }
    
    // Add signature button
    const addSignatureBtn = document.getElementById('add-signature-btn');
    if (addSignatureBtn) {
      addSignatureBtn.addEventListener('click', function(e) {
        e.preventDefault();
        addSignatureElement();
      });
    }
    
    // Save changes button
    const saveChangesBtn = document.getElementById('save-changes-btn');
    if (saveChangesBtn) {
      saveChangesBtn.addEventListener('click', function(e) {
        e.preventDefault();
        saveChanges();
      });
    }
    
    // Download button
    const downloadBtn = document.getElementById('download-pdf-btn');
    if (downloadBtn) {
      downloadBtn.addEventListener('click', function(e) {
        e.preventDefault();
        generateAndDownloadPdf();
      });
    }
    
    // Signature preview updates
    const signatureInput = document.getElementById('signature-input');
    if (signatureInput) {
      signatureInput.addEventListener('input', updateSignaturePreview);
    }
    
    const fontSelect = document.getElementById('signature-font');
    if (fontSelect) {
      fontSelect.addEventListener('change', updateSignaturePreview);
    }
  }
  
  function handlePdfClick(event) {
    const pdfViewer = document.getElementById('pdf-viewer');
    if (!pdfViewer) return;
    
    const rect = pdfViewer.getBoundingClientRect();
    const x = ((event.clientX - rect.left) / rect.width) * 100;
    const y = ((event.clientY - rect.top) / rect.height) * 100;
    
    selectedPosition = {
      x: parseFloat(x.toFixed(1)),
      y: parseFloat(y.toFixed(1))
    };
    
    updatePositionIndicators();
    console.log(`Position selected: x=${selectedPosition.x}%, y=${selectedPosition.y}%`);
  }
  
  function updatePositionIndicators() {
    const indicators = document.querySelectorAll('.position-indicator');
    indicators.forEach(indicator => {
      indicator.textContent = `Position: (${selectedPosition.x}%, ${selectedPosition.y}%)`;
    });
  }
  
  function addTextElement() {
    const textInput = document.getElementById('text-input');
    console.log('Adding text element, textInput:', textInput);
    if (!textInput || !textInput.value.trim()) {
      alert('Please enter some text');
      return;
    }
    
    const textContent = textInput.value.trim();
    
    // Try to detect what field this might be based on content
    const fieldHint = detectFieldType(textContent);
    
    // Generate a unique ID using timestamp + random to ensure uniqueness
    const uniqueId = Date.now() + Math.floor(Math.random() * 10000);
    
    const element = {
      id: uniqueId,
      type: 'text',
      content: textContent,
      field: fieldHint, // Add field hint for better positioning
      x: selectedPosition.x,
      y: selectedPosition.y,
      saved: true // Mark as saved from the beginning
    };
    
    // Save immediately to prevent duplication
    addElementAndSave(element);
    
    // Clear the input field completely
    textInput.value = '';
    
    // Force UI update
    setTimeout(() => {
      textInput.focus();
      textInput.blur();
    }, 50);
    
    window.showNotification('Text added successfully');
    console.log('Text input cleared:', textInput.value === '');

  }
  
  function addSignatureElement() {
    const signatureInput = document.getElementById('signature-input');
    const fontSelect = document.getElementById('signature-font');
    
    console.log('Adding signature element, signatureInput:', signatureInput);
    if (!signatureInput || !signatureInput.value.trim() || !fontSelect) {
      alert('Please enter your signature');
      return;
    }
    
    // Store values before clearing
    const signatureContent = signatureInput.value.trim();
    const fontValue = fontSelect.value;
    
    // Try to detect what field this might be (likely signature or name)
    const fieldHint = 'signature'; // Default to signature field type
    
    // Generate a unique ID using timestamp + random to ensure uniqueness
    const uniqueId = Date.now() + Math.floor(Math.random() * 10000);
    
    const element = {
      id: uniqueId,
      type: 'signature',
      content: signatureContent,
      font: fontValue,
      field: fieldHint,
      x: selectedPosition.x,
      y: selectedPosition.y,
      saved: true // Mark as saved from the beginning
    };
    
    // Save immediately to prevent duplication
    addElementAndSave(element);
    
    // Clear the input field completely
    signatureInput.value = '';
    
    // Force UI update
    setTimeout(() => {
      signatureInput.focus();
      signatureInput.blur();
      updateSignaturePreview();
    }, 50);
    
    window.showNotification('Signature added successfully');
    console.log('Signature input cleared:', signatureInput.value === '');

  }
  
  function createElementInDOM(element) {
    const pdfContainer = document.getElementById('pdf-container');
    if (!pdfContainer) return;
    
    // Get the PDF viewer dimensions for proper positioning
    const pdfViewer = document.getElementById('pdf-viewer');
    if (!pdfViewer) return;
    
    const el = document.createElement('div');
    el.className = `pdf-element ${element.type === 'signature' ? 'signature' : ''}`;
    
    // Position relative to the PDF viewer's bounding rect
    // This ensures the positions are fixed relative to the PDF content
    // regardless of screen size or layout changes
    const pdfRect = pdfViewer.getBoundingClientRect();
    el.style.position = 'absolute';
    el.style.left = element.x + '%';
    el.style.top = element.y + '%';
    el.dataset.elementId = element.id;
    el.dataset.xPercent = element.x;
    el.dataset.yPercent = element.y;
    el.setAttribute('aria-label', element.type === 'signature' ? 'Signature element' : 'Text element');
    
    // Create content
    let content;
    if (element.type === 'signature' && element.font) {
      content = document.createElement('span');
      content.textContent = element.content;
      content.style.fontFamily = getFontFamily(element.font);
      content.style.fontSize = getFontSize(element.font, element.content);
    } else {
      content = document.createElement('span');
      content.textContent = element.content;
    }
    
    el.appendChild(content);
    
    // Add remove button
    const removeBtn = document.createElement('div');
    removeBtn.className = 'remove-btn';
    removeBtn.innerHTML = '&times;';
    removeBtn.setAttribute('aria-label', 'Remove element');
    removeBtn.addEventListener('click', function() {
      removeElement(element.id);
    });
    
    el.appendChild(removeBtn);
    
    // Make draggable
    makeDraggable(el);
    
    pdfContainer.appendChild(el);
  }
  
  function makeDraggable(el) {
    let isDragging = false;
    let startX, startY;
    let startLeft, startTop;
    
    el.addEventListener('mousedown', function(e) {
      if (e.target.classList.contains('remove-btn')) return;
      
      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      
      startLeft = parseFloat(el.style.left);
      startTop = parseFloat(el.style.top);
      
      el.classList.add('dragging');
      e.preventDefault();
    });
    
    document.addEventListener('mousemove', function(e) {
      if (!isDragging) return;
      
      const pdfContainer = document.getElementById('pdf-container');
      if (!pdfContainer) return;
      
      const containerRect = pdfContainer.getBoundingClientRect();
      
      const deltaX = ((e.clientX - startX) / containerRect.width) * 100;
      const deltaY = ((e.clientY - startY) / containerRect.height) * 100;
      
      const newLeft = Math.max(0, Math.min(95, startLeft + deltaX));
      const newTop = Math.max(0, Math.min(95, startTop + deltaY));
      
      el.style.left = newLeft + '%';
      el.style.top = newTop + '%';
    });
    
    document.addEventListener('mouseup', function() {
      if (!isDragging) return;
      
      isDragging = false;
      el.classList.remove('dragging');
      
      const id = parseInt(el.dataset.elementId);
      const index = overlayElements.findIndex(item => item.id === id);
      
      if (index !== -1) {
        overlayElements[index].x = parseFloat(el.style.left);
        overlayElements[index].y = parseFloat(el.style.top);
      }
    });
  }
  
  function removeElement(id) {
    const el = document.querySelector(`.pdf-element[data-element-id="${id}"]`);
    if (el && el.parentElement) {
      el.parentElement.removeChild(el);
    }
    
    overlayElements = overlayElements.filter(item => item.id !== id);
  }
  
  function renderElements() {
    const pdfContainer = document.getElementById('pdf-container');
    if (!pdfContainer) return;
    
    // Clear all existing elements to prevent duplication
    const existingElements = pdfContainer.querySelectorAll('.pdf-element');
    existingElements.forEach(el => {
      if (el.parentElement) el.parentElement.removeChild(el);
    });
    
    // Make sure we have unique elements based on ID
    const uniqueElements = [];
    const processedIds = new Set();
    
    overlayElements.forEach(element => {
      // Skip if we've already processed this ID
      if (processedIds.has(element.id)) return;
      
      // Add to our unique elements array
      uniqueElements.push(element);
      processedIds.add(element.id);
    });
    
    // Replace the overlayElements array with unique elements
    overlayElements = uniqueElements;
    
    // Create DOM elements for each unique element
    overlayElements.forEach(element => createElementInDOM(element));
  }
  
  // Helper function to add element and save immediately to prevent duplication
  function addElementAndSave(element) {
    // Add to our array
    overlayElements.push(element);
    
    // Create the visual DOM element
    createElementInDOM(element);
    
    // Flag element as saved so it will be included in downloads
    element.saved = true;
    
    // Save to server immediately to prevent duplication on page reload
    const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
    if (!csrfToken) {
      console.error('CSRF token not found when trying to save new element');
      return;
    }
    
    // Prepare data to send with all elements to ensure consistency
    const dataToSend = JSON.stringify({
      elements: overlayElements
    });
    
    console.log('Saving elements to server:', overlayElements);
    
    // Make the save request
    fetch(`/pdf_documents/${pdfDocumentId}/save_elements`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': csrfToken
      },
      body: dataToSend
    })
    .then(response => {
      if (!response.ok) {
        console.error('Failed to save new element');
        // Mark element as unsaved if server rejected it
        element.saved = false;
      } else {
        console.log('Element saved successfully');
        // Ensure we update the global state consistently
        element.saved = true;
      }
    })
    .catch(error => {
      console.error('Error saving element:', error);
      element.saved = false;
    });
    
    // Return the element for chaining
    return element;
  }
  
  // Helper function to safely remove event listeners
  function cleanupEventListeners() {
    // Remove PDF overlay click listener
    const pdfOverlay = document.getElementById('pdf-overlay');
    if (pdfOverlay) {
      pdfOverlay.removeEventListener('click', handlePdfClick);
    }
    
    // Remove button listeners
    const addTextBtn = document.getElementById('add-text-btn');
    if (addTextBtn) {
      const newBtn = addTextBtn.cloneNode(true);
      addTextBtn.parentNode.replaceChild(newBtn, addTextBtn);
    }
    
    const addSignatureBtn = document.getElementById('add-signature-btn');
    if (addSignatureBtn) {
      const newBtn = addSignatureBtn.cloneNode(true);
      addSignatureBtn.parentNode.replaceChild(newBtn, addSignatureBtn);
    }
    
    const saveChangesBtn = document.getElementById('save-changes-btn');
    if (saveChangesBtn) {
      const newBtn = saveChangesBtn.cloneNode(true);
      saveChangesBtn.parentNode.replaceChild(newBtn, saveChangesBtn);
    }
    
    // Download is now a direct link - no event listeners to clean up
    
    // Remove signature preview listeners
    const signatureInput = document.getElementById('signature-input');
    if (signatureInput) {
      signatureInput.removeEventListener('input', updateSignaturePreview);
    }
    
    const fontSelect = document.getElementById('signature-font');
    if (fontSelect) {
      fontSelect.removeEventListener('change', updateSignaturePreview);
    }
  }
  
  function updateSignaturePreview() {
    const signatureInput = document.getElementById('signature-input');
    const fontSelect = document.getElementById('signature-font');
    const previewContainer = document.getElementById('signature-preview');
    
    if (!signatureInput || !fontSelect || !previewContainer) return;
    
    const text = signatureInput.value.trim();
    const font = fontSelect.value;
    
    if (!text) {
      previewContainer.innerHTML = '<div class="text-gray-400 italic text-sm">Type your name above to see preview</div>';
      return;
    }
    
    previewContainer.innerHTML = '';
    const previewSpan = document.createElement('span');
    previewSpan.textContent = text;
    previewSpan.style.fontFamily = getFontFamily(font);
    previewSpan.style.fontSize = getFontSize(font, text);
    
    previewContainer.appendChild(previewSpan);
  }
  
  function getFontFamily(font) {
    switch (font) {
      case 'Dancing Script': return '"Dancing Script", cursive';
      case 'Great Vibes': return '"Great Vibes", cursive';
      case 'Allura': return '"Allura", cursive';
      default: return '"Dancing Script", cursive';
    }
  }
  
  function getFontSize(font, text) {
    const baseSize = font === 'Great Vibes' ? 30 : (font === 'Allura' ? 28 : 26);
    
    if (text.length > 15) {
      return Math.max(baseSize - ((text.length - 15) * 0.7), 16) + 'px';
    }
    return baseSize + 'px';
  }
  
  // Helper function to detect what field a text input might be for
  function detectFieldType(text) {
    text = text.toLowerCase().trim();
    
    // Check for email format (contains @ symbol)
    if (text.includes('@')) {
      return 'email';
    }
    
    // Check for common field types based on content patterns
    if (/^[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$/.test(text)) {
      return 'email';
    } else if (/^\d{3}-?\d{3}-?\d{4}$/.test(text) || /^\(\d{3}\)-?\d{3}-?\d{4}$/.test(text)) {
      return 'phone';
    } else if (/^\d{5}(-\d{4})?$/.test(text)) {
      return 'zip';
    } else if (/^[A-Z][a-zA-Z\s.]{0,25}$/.test(text) && text.length <= 30) {
      return 'name';
    } else if (/[0-9]+ [A-Za-z\s]+/.test(text)) {
      return 'address';
    } else if (text.length === 2 && /^[A-Z]{2}$/.test(text)) {
      return 'state';
    } else if (text.length <= 20 && !/\d/.test(text)) {
      return 'city';
    }
    
    // Default if no pattern matches
    return '';
  }
  
  function saveChanges() {
    // Show saving state
    const saveBtn = document.getElementById('save-changes-btn');
    if (saveBtn) {
      saveBtn.textContent = 'Saving...';
      saveBtn.disabled = true;
    }
    
    // Make sure we only have unique elements before saving
    const uniqueElements = [];
    const processedIds = new Set();
    
    overlayElements.forEach(element => {
      if (!processedIds.has(element.id)) {
        uniqueElements.push(element);
        processedIds.add(element.id);
      }
    });
    
    // Replace the original array with unique elements
    overlayElements = uniqueElements;
    
    const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
    if (!csrfToken) {
      console.error('CSRF token not found');
      window.showNotification('Security error: CSRF token not found', 'error');
      if (saveBtn) {
        saveBtn.textContent = 'Save Changes';
        saveBtn.disabled = false;
      }
      return;
    }
    
    // Prevent saving empty elements array if it would cause a server error
    const elementsToSave = overlayElements || [];
    if (elementsToSave.length === 0) {
      // If we're trying to save an empty array (all elements deleted),
      // we should still try to save but with at least an empty placeholder
      elementsToSave.push({
        id: 'placeholder',
        type: 'placeholder',
        content: '',
        x: 0,
        y: 0
      });
    }
    
    // Prepare data to send
    const dataToSend = JSON.stringify({
      elements: elementsToSave
    });
    console.log('Sending data:', dataToSend);
    
    // Make the fetch request
    fetch(`/pdf_documents/${pdfDocumentId}/save_elements`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': csrfToken
      },
      body: dataToSend
    })
    .then(response => {
      console.log('Response status:', response.status);
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}`);
      }
      return response.text().then(text => {
        // Try to parse as JSON, but handle if it's not valid JSON
        try {
          return { json: JSON.parse(text), text, isJson: true };
        } catch (e) {
          console.log('Response is not JSON:', text);
          return { text, isJson: false };
        }
      });
    })
    .catch(error => {
      console.error('Network error or server error:', error);
      window.showNotification('Error saving changes: ' + error.message, 'error');
      throw error; // Re-throw to be caught by the outer catch
    })
    .then(result => {
      if (result.isJson && result.json.status === 'success') {
        window.showNotification('All changes saved successfully', 'success');
      } else {
        console.error('Error in save response:', result.text);
        window.showNotification('Changes may not have been saved properly', 'warning');
      }
      
      // Reset button state
      if (saveBtn) {
        saveBtn.textContent = 'Save Changes';
        saveBtn.disabled = false;
      }
    })
    .catch(error => {
      console.error('Error saving changes:', error);
      window.showNotification('Error saving changes: ' + error.message, 'error');
      
      // Reset button state
      if (saveBtn) {
        saveBtn.textContent = 'Save Changes';
        saveBtn.disabled = false;
      }
    });
  }
  
  function generateAndDownloadPdf() {
    // Log to console for debugging purposes
    console.log('Starting PDF generation and download process');
    console.log('Current PDF ID:', pdfDocumentId);
    console.log('Current overlay elements:', overlayElements);
    
    // Validate that we're still working with the correct PDF
    if (!validateCurrentPdf()) {
      console.error('PDF ID mismatch! Attempted to generate PDF for wrong document.');
      window.showNotification('Error: You appear to be working with a different PDF. Please refresh the page.', 'error');
      return;
    }
    
    const downloadBtn = document.getElementById('download-pdf-btn');
    if (downloadBtn) {
      downloadBtn.textContent = 'Processing...';
      downloadBtn.disabled = true;
    }
    
    // Make sure we have all elements - both saved and floating ones
    // We'll deduplicate them to avoid any issues
    const uniqueElements = [];
    const processedIds = new Set();
    const processedPositions = new Set();
    
    // Process all elements to keep only unique ones and ensure they're properly saved
    overlayElements.forEach(element => {
      // Create a position key to catch duplicates at same position
      const posKey = `${element.type}_${element.x.toFixed(1)}_${element.y.toFixed(1)}_${element.content}`;
      
      // Only include if we haven't seen this ID or position before
      if (!processedIds.has(element.id) && !processedPositions.has(posKey)) {
        // Mark as saved so it gets included in the download
        element.saved = true;
        uniqueElements.push(element);
        processedIds.add(element.id);
        processedPositions.add(posKey);
      }
    });
    
    // Replace the original array with cleaned unique elements
    overlayElements = uniqueElements;
    console.log('Preparing download with elements:', overlayElements);
    
    // Save current state of overlays including floating elements
    const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
    if (!csrfToken) {
      window.showNotification('Security error: CSRF token not found', 'error');
      if (downloadBtn) {
        downloadBtn.textContent = 'Download PDF';
        downloadBtn.disabled = false;
      }
      return;
    }
    
    // Prevent saving empty elements array if it would cause a server error
    const elementsToSave = overlayElements || [];
    if (elementsToSave.length === 0) {
      // If we're trying to save an empty array (all elements deleted),
      // we should still try to save but with at least an empty placeholder
      elementsToSave.push({
        id: 'placeholder',
        type: 'placeholder',
        content: '',
        x: 0,
        y: 0
      });
    }
    
    // Show progress notification
    window.showNotification('Saving changes before download...', 'info');
    
    // Save the elements first
    fetch(`/pdf_documents/${pdfDocumentId}/save_elements`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': csrfToken
      },
      body: JSON.stringify({ elements: elementsToSave })
    })
    .then(response => {
      console.log('Save response status:', response.status);
      if (!response.ok) {
        throw new Error(`Server returned ${response.status} when saving changes`);
      }
      
      // Now apply the changes to generate the processed PDF
      window.showNotification('Changes saved, processing PDF...', 'info');
      return fetch(`/pdf_documents/${pdfDocumentId}/apply_changes`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': csrfToken
        }
      });
    })
    .catch(error => {
      // If we get here, it means the save_elements request failed
      console.error('Error saving elements:', error);
      throw new Error('Failed to save elements: ' + error.message);
    })
    .then(response => {
      console.log('Apply changes response status:', response.status);
      if (!response.ok) {
        throw new Error(`Server returned ${response.status} when applying changes`);
      }
      
      // For apply_changes, we know we're expecting JSON, but sometimes the server returns HTML
      // Let's properly handle all formats
      return response.text().then(text => {
        // Try to parse as JSON first
        try {
          return JSON.parse(text);
        } catch (e) {
          // Check if this looks like HTML (has HTML tags)
          if (text.includes('<html') || text.includes('<!DOCTYPE')) {
            console.log('Server returned HTML instead of JSON');
            // If this is the download PDF flow, it's actually a success - the PDF was generated
            if (text.includes('PDF Form Editor')) {
              console.log('HTML indicates PDF was generated successfully');
              return { 
                status: 'success', 
                message: 'PDF generated successfully', 
                isHtmlResponse: true 
              };
            } else {
              // Otherwise, it's probably an error page
              throw new Error('Server returned HTML error page');
            }
          } else {
            // Just regular text that's not JSON or HTML
            console.warn('Server returned non-JSON, non-HTML response:', text);
            return { status: 'success', message: 'Processing complete' };
          }
        }
      });
    })
    .catch(error => {
      // If we get here, it means the apply_changes request failed
      console.error('Error applying changes:', error);
      throw new Error('Failed to process PDF: ' + error.message);
    })
    .then(data => {
      if (data.status === 'success') {
        window.showNotification('PDF processed successfully, starting download...', 'success');
        
        // Reset download button
        if (downloadBtn) {
          downloadBtn.textContent = 'Download PDF';
          downloadBtn.disabled = false;
        }
        
        // Now download the processed PDF
        const downloadUrl = `/pdf_documents/${pdfDocumentId}/download?t=${new Date().getTime()}`;
        console.log('Initiating download from:', downloadUrl);
        
        // Create an actual anchor element for the download
        const downloadLink = document.createElement('a');
        downloadLink.href = downloadUrl;
        downloadLink.download = "processed-" + pdfDocumentId + ".pdf";
        downloadLink.target = "_blank";
        downloadLink.style.display = "none";
        document.body.appendChild(downloadLink);
        
        // Trigger click on the download link
        console.log('Triggering download click');
        downloadLink.click();
        
        // Clean up
        setTimeout(() => {
          document.body.removeChild(downloadLink);
        }, 1000);
        
        // For a better UX, show instructions if download doesn't start
        setTimeout(() => {
          const message = document.createElement('div');
          message.innerHTML = `If download doesn't start automatically, <a href="${downloadUrl}" target="_blank" style="text-decoration:underline;color:white;">click here</a>`;
          
          window.showNotification(message.innerHTML, 'info');
        }, 3000);
      } else {
        throw new Error(data.message || 'Failed to process PDF');
      }
    })
    .catch(error => {
      console.error('Error saving/processing/downloading PDF:', error);
      window.showNotification('Error: ' + error.message, 'error');
      
      // Reset download button in case of any error
      if (downloadBtn) {
        downloadBtn.textContent = 'Download PDF';
        downloadBtn.disabled = false;
      }
    });
  }
</script>
